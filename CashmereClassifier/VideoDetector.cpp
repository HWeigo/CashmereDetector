#include "VideoDetector.h"
#include "AutoDetector.h"

VideoDetector::VideoDetector(Ui::CashmereDetectorClass ui) : BaseDetector(ui) {

}

void VideoDetector::LoadVideo(string filePath)
{
	capture_.open(filePath);
	//ShowVideo();
	VideoAutoCrop();
}

void VideoDetector::ShowVideo()
{
	Mat currFrame;
	while (capture_.read(currFrame)) {
		BaseDetector::LoadImg(currFrame);
		ShowCurrImg();
		//imshow("frame", currFrame);
		waitKey(1);
	}
}

double calLaplacian(cv::Mat &image)
{
	cv::Mat grayImg, lapImage;
	if (image.channels() == 3) {
		cv::cvtColor(image, grayImg, COLOR_BGR2GRAY);
	}

	cv::Laplacian(grayImg, lapImage, CV_32FC1);
	lapImage = cv::abs(lapImage);

	return cv::mean(lapImage)[0];
}

Mat RegionDetect(Mat srcImg) {

	// Local iconic variables
	HObject  ho_Image11, ho_Image2, ho_Region;
	HObject  ho_ConnectedRegions, ho_RegionFillUp, ho_SelectedRegions2;
	HObject  ho_SelectedRegions1, ho_RegionClosing, ho_Skeleton;
	HObject  ho_Contours;

	// Local control variables
	HTuple  hv_Width, hv_Height, hv_WindowHandle;
	HTuple  hv_Channels, hv_Grayval, hv_Area, hv_Row, hv_Column;
	HTuple  hv_Number;

	HObject ho_Image1;
	ho_Image1 = MatToHObject(srcImg);

	//Image Acquisition 01: Do something
	if (HDevWindowStack::IsOpen())
		CloseWindow(HDevWindowStack::Pop());
	GetImageSize(ho_Image1, &hv_Width, &hv_Height); // DONT COMMENT THIS!!!!!!


													//blob分析挑选出测量区域（形状特征的选择）

													//判断通道数，若为3通道，则对图像灰度化
	CountChannels(ho_Image1, &hv_Channels);
	if (0 != (hv_Channels == 3))
	{
		Decompose3(ho_Image1, &ho_Image11, &ho_Image2, &ho_Image1);
	}
	GetGrayval(ho_Image1, 0, 0, &hv_Grayval);
	Threshold(ho_Image1, &ho_Region, 0, hv_Grayval - 1);
	Connection(ho_Region, &ho_ConnectedRegions);
	FillUp(ho_ConnectedRegions, &ho_RegionFillUp);

	//形状选择
	SelectShape(ho_RegionFillUp, &ho_SelectedRegions2, "circularity", "and", 0, 0.1676);
	AreaCenter(ho_SelectedRegions2, &hv_Area, &hv_Row, &hv_Column);
	SelectShape(ho_SelectedRegions2, &ho_SelectedRegions1, "area", "and", hv_Area.TupleMax(),
		9999999);
	ClosingCircle(ho_SelectedRegions1, &ho_RegionClosing, 35);

	Skeleton(ho_RegionClosing, &ho_Skeleton);
	GenContourRegionXld(ho_RegionClosing, &ho_Contours, "border");


	CountObj(ho_SelectedRegions1, &hv_Number);

	//显示结果
	HObject ho_BinImage;
	RegionToBin(ho_RegionClosing, &ho_BinImage, 255, 0, hv_Width, hv_Height);
	//WriteImage(ho_BinImage, "bmp", 0, 
	//			  "D:/OneDrive@sjtu.edu.cn/ALGO/wool cashmere/CashmereDetector/CashmereDetector/region.bmp");
	Mat dstImg;
	HObject2Mat(ho_BinImage, dstImg);
	return dstImg;
}

vector<Mat> MultiRegionDetect(Mat srcImg) {
	// Local iconic variables
	HObject  ho_Image, ho_GaussFilter1, ho_GaussFilter2;
	HObject  ho_Filter, ho_ImageG, ho_ImageFFT, ho_ImageConvol;
	HObject  ho_ImageFiltered, ho_ImageResult, ho_RegionDynThresh;
	HObject  ho_ConnectedRegions, ho_Rectangle, ho_Rectangle1;
	HObject  ho_Rectangle2, ho_RegionDifference, ho_RegionDifference1;
	HObject  ho_RegionUnion, ho_RegionFillUp, ho_SelectedRegions2;
	HObject  ho_SelectedRegions1, ho_RegionErosion, ho_RegionOpening;
	HObject  ho_ConnectedRegions1, ho_RegionOpening1, ho_ImageReduced;
	HObject  ho_RegionOpening2;

	// Local control variables
	HTuple  hv_Width, hv_Height, hv_WindowHandle;
	HTuple  hv_Sigma1, hv_Sigma2, hv_Min, hv_Max, hv_Range;
	HTuple  hv_Area, hv_Row, hv_Column, hv_Number, hv_Index2;


	//This program demonstrates how to detect small texture
	//defects on the surface of plastic items by using the fast
	//fourier transform (FFT).
	//First, we construct a suitable filter using Gaussian
	//filters. Then, the images and the filter are convolved
	//by using fast fourier transforms. Finally, the defects
	//are detected in the filtered images by using
	//morphology operators.
	//


	//if (HDevWindowStack::IsOpen())
	//  SetDraw(HDevWindowStack::GetActive(),"fill");
	//if (HDevWindowStack::IsOpen())
	//  SetLineWidth(HDevWindowStack::GetActive(),3);
	//if (HDevWindowStack::IsOpen())
	//  SetColor(HDevWindowStack::GetActive(),"red");
	//Image Acquisition 01: Code generated by Image Acquisition 01

	ho_Image = MatToHObject(srcImg);
	//ReadImage(&ho_Image, //'C:/Users/sunzc/Desktop/��ë��Ŀ/428fec52550e65a9198d7f91d3ab37a.jpg'
	//    "C:/Users/sunzc/Desktop/\321\362\303\253\317\356\304\277/428fec52550e65a9198d7f91d3ab37a.jpg");
	//Image Acquisition 01: Do something
	if (HDevWindowStack::IsOpen())
		CloseWindow(HDevWindowStack::Pop());
	GetImageSize(ho_Image, &hv_Width, &hv_Height);
	//dev_open_window_fit_image(ho_Image, 0, 0, -1, -1, &hv_WindowHandle);

	//dev_update_off();

	hv_Sigma1 = 5.0;
	hv_Sigma2 = 0.0;
	GenGaussFilter(&ho_GaussFilter1, hv_Sigma1, hv_Sigma1, 0.0, "none", "rft", hv_Width,
		hv_Height);
	GenGaussFilter(&ho_GaussFilter2, hv_Sigma2, hv_Sigma2, 0.0, "none", "rft", hv_Width,
		hv_Height);
	SubImage(ho_GaussFilter1, ho_GaussFilter2, &ho_Filter, 1, 0);

	Rgb1ToGray(ho_Image, &ho_ImageG);
	//Perform the convolution in the frequency domain
	RftGeneric(ho_ImageG, &ho_ImageFFT, "to_freq", "none", "complex", hv_Width);
	ConvolFft(ho_ImageFFT, ho_Filter, &ho_ImageConvol);
	RftGeneric(ho_ImageConvol, &ho_ImageFiltered, "from_freq", "n", "real", hv_Width);
	//
	//Process the filtered image
	GrayRangeRect(ho_ImageFiltered, &ho_ImageResult, 10, 10);
	MinMaxGray(ho_ImageResult, ho_ImageResult, 0, &hv_Min, &hv_Max, &hv_Range);
	Threshold(ho_ImageResult, &ho_RegionDynThresh, (HTuple(5.55).TupleConcat(hv_Max*0.1)).TupleMax(),
		255);
	//threshold (ImageResult, Region, 0, 10)
	//dilation_circle (Region, Region, 5)

	//fill_up (Region, RegionFillUp1)

	Connection(ho_RegionDynThresh, &ho_ConnectedRegions);

	//closing_circle (ConnectedRegions, RegionClosing, 30)
	GenRectangle1(&ho_Rectangle, 0, 0, hv_Height, hv_Width);
	GenRectangle1(&ho_Rectangle1, 1, 1, hv_Height - 2, hv_Width - 2);
	GenRectangle1(&ho_Rectangle2, 0, 0, 1, 1);
	Difference(ho_Rectangle, ho_Rectangle1, &ho_RegionDifference);
	Difference(ho_RegionDifference, ho_Rectangle2, &ho_RegionDifference1);

	Union2(ho_ConnectedRegions, ho_RegionDifference1, &ho_RegionUnion);

	FillUp(ho_RegionUnion, &ho_RegionFillUp);
	Difference(ho_RegionFillUp, ho_RegionDifference1, &ho_RegionFillUp);
	//��״ѡ��
	SelectShape(ho_RegionFillUp, &ho_SelectedRegions2, "circularity", "and", 0, 0.20);
	AreaCenter(ho_SelectedRegions2, &hv_Area, &hv_Row, &hv_Column);
	SelectShape(ho_SelectedRegions2, &ho_SelectedRegions1, "area", "and", 10000, 9999999);
	//closing_circle (SelectedRegions1, RegionClosing, 35)

	ErosionCircle(ho_SelectedRegions1, &ho_RegionErosion, 5);
	OpeningCircle(ho_RegionErosion, &ho_RegionOpening, 10);

	//difference (RegionOpening, Region, RegionDifference)
	FillUp(ho_RegionOpening, &ho_RegionOpening);
	Connection(ho_RegionOpening, &ho_ConnectedRegions1);
	SelectShape(ho_ConnectedRegions1, &ho_RegionOpening, "area", "and", 10000, 9999999);
	OpeningCircle(ho_RegionOpening, &ho_RegionOpening1, 20);
	CountObj(ho_RegionOpening, &hv_Number);

	vector<Mat> ret;
	if (0 != (hv_Number == 1)) {
		ReduceDomain(ho_Image, ho_RegionOpening, &ho_ImageReduced);
		//if (HDevWindowStack::IsOpen())
		//	DispObj(ho_ImageReduced, HDevWindowStack::GetActive());
		WriteImage(ho_ImageReduced, "jpg", 0,
			"./REGION_RESULT.jpg");
		Mat dstMat;
		dstMat = imread("REGION_RESULT.jpg");
		ret.push_back(dstMat);
	} else {
			HTuple end_val93 = hv_Number;
			HTuple step_val93 = 1;
			int idx = 0;
			for (hv_Index2 = 1; hv_Index2.Continue(end_val93, step_val93); hv_Index2 += step_val93) {
				cout << "multi" << endl;
				SelectObj(ho_RegionOpening, &ho_RegionOpening2, hv_Index2);
				ReduceDomain(ho_Image, ho_RegionOpening2, &ho_ImageReduced);
				WriteImage(ho_ImageReduced, "jpg", 0,
					"./REGION_RESULT.jpg");
				Mat dstMat;
				dstMat = imread("REGION_RESULT.jpg");
				ret.push_back(dstMat);
			}
	}
	return ret;
}

Mat getBestFrame(vector<Mat>& frameVec) {
	// select the best frame from the vector
	vector<double> scoreVec;
	int bestIdx = 0;
	int maxScore = 0;
	const int Q = 1e2;

	// cout << "frameVec.size() = " << frameVec.size() << endl;
	//for (int i = 0; i < frameVec.size(); ++i) {
	//	Mat curFrame;
	//	frameVec[i].copyTo(curFrame);
	//	string name = "debug_" + to_string(i) + ".jpg";
	//	imwrite(name, curFrame);
	//}
	for (int i = 0; i < frameVec.size(); i++) {
		Mat curFrame;
		frameVec[i].copyTo(curFrame);
		//Mat regionImg = RegionDetect(curFrame);
		double lapVal = calLaplacian(curFrame);	
		vector<Mat> regionImgs = MultiRegionDetect(curFrame);
		
		cout << "num: " << regionImgs.size() << endl;
		//imshow("curr", curFrame);
		imwrite("./debug_40.jpg", curFrame);
		//waitKey(0);
		for (int j = 0; j < regionImgs.size(); ++j) {
			Mat regionImg;
			regionImgs[j].copyTo(regionImg);
			imwrite("./region_40_" + to_string(i) + "_" + to_string(j) + ".jpg", regionImg);

			// 需要二值化的结果
			vector<vector<Point>> contours;
			vector<Vec4i> hierarchy;
			findContours(regionImg, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point());
			int contoursNum = contours.size();

			// cout << lapVal << endl;
			double curScore = Q*lapVal*1.f / contoursNum; // improve
			if (curScore > maxScore) {
				maxScore = curScore;
				bestIdx = i;
			}
		}
	}

	return frameVec[bestIdx];
}

void VideoDetector::VideoAutoCrop() {
	if (!capture_.isOpened())
		return;

	Mat curFrame;
	Mat preFrame;
	int frameCnt = 0;

	capture_.read(curFrame);

	vector<int> frameDiffVec;	
	fstream file;	
	file.open("result.txt", ios_base::out);

	int contFrameThresh = 25;
	double updateThresh = 0.5;
	int numThresh = 1.3e6;
	//int numThresh = 3e6;

	Mat tmpStore;
	int conFrameCnt = 0;
	bool storedFlag = false;
	
	string storeFileName = "./videoCrops/";
	int storeCnt = 0;

	vector<Mat> tmpFrameVec;

	while (capture_.read(curFrame))
	{
		BaseDetector::LoadImg(curFrame);
		ShowCurrImg();
		++frameCnt;

		if (frameCnt >= 2) {
			Mat frameDiff;

			//imshow("origin", curFrame);
			//imshow("prev", preFrame);
			absdiff(curFrame, preFrame, frameDiff);
			Scalar channleDiff = sum(frameDiff);
			int pixelDiffSum = channleDiff[0]+ channleDiff[1] + channleDiff[2];
			frameDiffVec.push_back(pixelDiffSum);

			++conFrameCnt;
			if (!storedFlag) {
				curFrame.copyTo(tmpStore);
				tmpFrameVec.push_back(curFrame);
				storedFlag = true;
			}
			else {
				double randNum = rand() / double(RAND_MAX);
				if (randNum < updateThresh) {
					curFrame.copyTo(tmpStore);
					tmpFrameVec.push_back(curFrame);
				}		
			}
			cout << pixelDiffSum << "  " << conFrameCnt << endl;
			if (pixelDiffSum > numThresh) {
				if (conFrameCnt > contFrameThresh && !tmpFrameVec.empty()) {
					//cout << curFrame.type() << endl;
					imwrite(storeFileName + to_string(++storeCnt) + ".png", getBestFrame(tmpFrameVec));
					//imwrite(storeFileName + to_string(++storeCnt) + ".png", curFrame);
					cout << "img save" << endl;
				}
				tmpFrameVec.clear();
				tmpFrameVec.resize(0);
				conFrameCnt = 0;
				storedFlag = false;
			}

			file << pixelDiffSum << endl;
			 //imshow("diff", frameDiff);
		}
		curFrame.copyTo(preFrame);
		waitKey(1);
	}
	file.close();
	capture_.release();
}



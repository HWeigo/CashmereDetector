///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 18.11.0.1
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && (defined(__i386__) || defined(__x86_64__)) \
                         && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;

// Procedure declarations 
// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle);
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ();
// Local procedures 
// Short Description: Displays the dimension of the measured edge pairs. 
void p_disp_dimensions (HTuple hv_RowEdgeFirst, HTuple hv_ColumnEdgeFirst, HTuple hv_RowEdgeSecond, 
    HTuple hv_ColumnEdgeSecond, HTuple hv_IntraDistance, HTuple hv_InterDistance, 
    HTuple hv_Phi, HTuple hv_Length, HTuple hv_WindowHandle);
// Short Description: Displays a marker, which indicates the position of an edge 
void p_disp_edge_marker (HTuple hv_Row, HTuple hv_Col, HTuple hv_Phi, HTuple hv_Length, 
    HTuple hv_Color, HTuple hv_LineWidth, HTuple hv_WindowHandle);
// Short Description: Displays text right of the center of two given points. 
void p_disp_text_left_of_center (HTuple hv_WindowHandle, HTuple hv_Text, HTuple hv_RowFirst, 
    HTuple hv_ColFirst, HTuple hv_RowSecond, HTuple hv_ColSecond, HTuple hv_Phi, 
    HTuple hv_Distance);
// Short Description: Displays text right of the center of two given points. 
void p_disp_text_right_of_center (HTuple hv_WindowHandle, HTuple hv_Text, HTuple hv_RowFirst, 
    HTuple hv_ColFirst, HTuple hv_RowSecond, HTuple hv_ColSecond, HTuple hv_Phi, 
    HTuple hv_Distance);

// Procedures 
// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MinWidth, hv_MaxWidth, hv_MinHeight;
  HTuple  hv_MaxHeight, hv_ResizeFactor, hv_ImageWidth, hv_ImageHeight;
  HTuple  hv_TempWidth, hv_TempHeight, hv_WindowWidth, hv_WindowHeight;

  //This procedure opens a new graphics window and adjusts the size
  //such that it fits into the limits specified by WidthLimit
  //and HeightLimit, but also maintains the correct image aspect ratio.
  //
  //If it is impossible to match the minimum and maximum extent requirements
  //at the same time (f.e. if the image is very long but narrow),
  //the maximum value gets a higher priority,
  //
  //Parse input tuple WidthLimit
  if (0 != (HTuple((hv_WidthLimit.TupleLength())==0).TupleOr(hv_WidthLimit<0)))
  {
    hv_MinWidth = 500;
    hv_MaxWidth = 800;
  }
  else if (0 != ((hv_WidthLimit.TupleLength())==1))
  {
    hv_MinWidth = 0;
    hv_MaxWidth = hv_WidthLimit;
  }
  else
  {
    hv_MinWidth = ((const HTuple&)hv_WidthLimit)[0];
    hv_MaxWidth = ((const HTuple&)hv_WidthLimit)[1];
  }
  //Parse input tuple HeightLimit
  if (0 != (HTuple((hv_HeightLimit.TupleLength())==0).TupleOr(hv_HeightLimit<0)))
  {
    hv_MinHeight = 400;
    hv_MaxHeight = 600;
  }
  else if (0 != ((hv_HeightLimit.TupleLength())==1))
  {
    hv_MinHeight = 0;
    hv_MaxHeight = hv_HeightLimit;
  }
  else
  {
    hv_MinHeight = ((const HTuple&)hv_HeightLimit)[0];
    hv_MaxHeight = ((const HTuple&)hv_HeightLimit)[1];
  }
  //
  //Test, if window size has to be changed.
  hv_ResizeFactor = 1;
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  //First, expand window to the minimum extents (if necessary).
  if (0 != (HTuple(hv_MinWidth>hv_ImageWidth).TupleOr(hv_MinHeight>hv_ImageHeight)))
  {
    hv_ResizeFactor = (((hv_MinWidth.TupleReal())/hv_ImageWidth).TupleConcat((hv_MinHeight.TupleReal())/hv_ImageHeight)).TupleMax();
  }
  hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
  //Then, shrink window to maximum extents (if necessary).
  if (0 != (HTuple(hv_MaxWidth<hv_TempWidth).TupleOr(hv_MaxHeight<hv_TempHeight)))
  {
    hv_ResizeFactor = hv_ResizeFactor*((((hv_MaxWidth.TupleReal())/hv_TempWidth).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight)).TupleMin());
  }
  hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
  //Resize window
  SetWindowAttr("background_color","black");
  OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"visible","",&(*hv_WindowHandle));
  HDevWindowStack::Push((*hv_WindowHandle));
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, hv_ImageHeight-1, hv_ImageWidth-1);
  return;
}

// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ()
{

  //This procedure sets different update settings to 'off'.
  //This is useful to get the best performance and reduce overhead.
  //
  // dev_update_pc(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  return;
}

// Local procedures 
// Short Description: Displays the dimension of the measured edge pairs. 
void p_disp_dimensions (HTuple hv_RowEdgeFirst, HTuple hv_ColumnEdgeFirst, HTuple hv_RowEdgeSecond, 
    HTuple hv_ColumnEdgeSecond, HTuple hv_IntraDistance, HTuple hv_InterDistance, 
    HTuple hv_Phi, HTuple hv_Length, HTuple hv_WindowHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Number, hv_i, hv_Text;

  //Loop over all edge pairs.
  hv_Number = hv_RowEdgeFirst.TupleLength();
  {
  HTuple end_val2 = hv_Number-1;
  HTuple step_val2 = 1;
  for (hv_i=0; hv_i.Continue(end_val2, step_val2); hv_i += step_val2)
  {
    //
    //Display markers for the edges.
    p_disp_edge_marker(HTuple(hv_RowEdgeFirst[hv_i]), HTuple(hv_ColumnEdgeFirst[hv_i]), 
        hv_Phi, hv_Length, "white", 2, hv_WindowHandle);
    p_disp_edge_marker(HTuple(hv_RowEdgeSecond[hv_i]), HTuple(hv_ColumnEdgeSecond[hv_i]), 
        hv_Phi, hv_Length, "white", 2, hv_WindowHandle);
    //
    //Display the IntraDistance between the edges.
    hv_Text = HTuple(hv_IntraDistance[hv_i]);
    p_disp_text_right_of_center(hv_WindowHandle, hv_Text.TupleString(".2f"), HTuple(hv_RowEdgeFirst[hv_i]), 
        HTuple(hv_ColumnEdgeFirst[hv_i]), HTuple(hv_RowEdgeSecond[hv_i]), HTuple(hv_ColumnEdgeSecond[hv_i]), 
        hv_Phi, 2.0*hv_Length);
  }
  }
  //
  //Loop to display the distance between the edge pairs.
  {
  HTuple end_val14 = hv_Number-2;
  HTuple step_val14 = 1;
  for (hv_i=0; hv_i.Continue(end_val14, step_val14); hv_i += step_val14)
  {
    //
    //Display the InterDistance between the edge pairs.
    hv_Text = HTuple(hv_InterDistance[hv_i]);
    p_disp_text_left_of_center(hv_WindowHandle, hv_Text.TupleString(".2f"), HTuple(hv_RowEdgeSecond[hv_i]), 
        HTuple(hv_ColumnEdgeSecond[hv_i]), HTuple(hv_RowEdgeFirst[hv_i+1]), HTuple(hv_ColumnEdgeFirst[hv_i+1]), 
        hv_Phi, 2.0*hv_Length);
  }
  }
  return;
}

// Short Description: Displays a marker, which indicates the position of an edge 
void p_disp_edge_marker (HTuple hv_Row, HTuple hv_Col, HTuple hv_Phi, HTuple hv_Length, 
    HTuple hv_Color, HTuple hv_LineWidth, HTuple hv_WindowHandle)
{

  // Local iconic variables
  HObject  ho_Marker;

  // Local control variables
  HTuple  hv_RowStart, hv_RowEnd, hv_ColStart, hv_ColEnd;

  //Determine start and end point of the edge marker.
  hv_RowStart = hv_Row+(hv_Length*(hv_Phi.TupleCos()));
  hv_RowEnd = hv_Row-(hv_Length*(hv_Phi.TupleCos()));
  hv_ColStart = hv_Col+(hv_Length*(hv_Phi.TupleSin()));
  hv_ColEnd = hv_Col-(hv_Length*(hv_Phi.TupleSin()));
  //
  //Generate a contour that connects the start and end point.
  GenContourPolygonXld(&ho_Marker, hv_RowStart.TupleConcat(hv_RowEnd), hv_ColStart.TupleConcat(hv_ColEnd));
  //
  //Display the contour with  the specified style.
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),hv_Color);
  if (HDevWindowStack::IsOpen())
    SetLineWidth(HDevWindowStack::GetActive(),hv_LineWidth);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Marker, HDevWindowStack::GetActive());
  //
  //Reset the line width.
  if (HDevWindowStack::IsOpen())
    SetLineWidth(HDevWindowStack::GetActive(),1);
  return;
}

// Short Description: Displays text right of the center of two given points. 
void p_disp_text_left_of_center (HTuple hv_WindowHandle, HTuple hv_Text, HTuple hv_RowFirst, 
    HTuple hv_ColFirst, HTuple hv_RowSecond, HTuple hv_ColSecond, HTuple hv_Phi, 
    HTuple hv_Distance)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Row1Part, hv_Column1Part, hv_Row2Part;
  HTuple  hv_Column2Part, hv_RowWin, hv_ColumnWin, hv_WidthWin;
  HTuple  hv_HeightWin, hv_FactorRow, hv_FactorColumn, hv_Ascent;
  HTuple  hv_Descent, hv_Width, hv_Height, hv_RowCenter, hv_ColCenter;
  HTuple  hv_RowPos, hv_ColPos, hv_RowText, hv_ColText;

  //Determine factors for the adaptation of the string extents that might be necessary
  //because of image zooming.
  GetPart(hv_WindowHandle, &hv_Row1Part, &hv_Column1Part, &hv_Row2Part, &hv_Column2Part);
  GetWindowExtents(hv_WindowHandle, &hv_RowWin, &hv_ColumnWin, &hv_WidthWin, &hv_HeightWin);
  hv_FactorRow = (1.*((hv_Row2Part-hv_Row1Part)+1))/hv_HeightWin;
  hv_FactorColumn = (1.*((hv_Column2Part-hv_Column1Part)+1))/hv_WidthWin;
  //
  //Determine the extent of the string and its position.
  GetStringExtents(hv_WindowHandle, hv_Text, &hv_Ascent, &hv_Descent, &hv_Width, 
      &hv_Height);
  hv_Width = hv_Width*hv_FactorColumn;
  hv_Height = hv_Height*hv_FactorRow;
  hv_RowCenter = (hv_RowFirst+hv_RowSecond)/2.0;
  hv_ColCenter = (hv_ColFirst+hv_ColSecond)/2.0;
  if (0 != ((hv_Phi.TupleSin())<0))
  {
    hv_Distance = -hv_Distance;
  }
  hv_RowPos = hv_RowCenter-(hv_Distance*(hv_Phi.TupleCos()));
  hv_ColPos = hv_ColCenter-(hv_Distance*(hv_Phi.TupleSin()));
  hv_RowText = hv_RowPos-(hv_Height/2.0);
  hv_ColText = hv_ColPos-hv_Width;
  //
  //Set the text position and color and display the text.
  SetTposition(hv_WindowHandle, hv_RowText, hv_ColText);
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"black");
  WriteString(hv_WindowHandle, hv_Text);
  return;
}

// Short Description: Displays text right of the center of two given points. 
void p_disp_text_right_of_center (HTuple hv_WindowHandle, HTuple hv_Text, HTuple hv_RowFirst, 
    HTuple hv_ColFirst, HTuple hv_RowSecond, HTuple hv_ColSecond, HTuple hv_Phi, 
    HTuple hv_Distance)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Row1Part, hv_Column1Part, hv_Row2Part;
  HTuple  hv_Column2Part, hv_RowWin, hv_ColumnWin, hv_WidthWin;
  HTuple  hv_HeightWin, hv_FactorRow, hv_FactorColumn, hv_Ascent;
  HTuple  hv_Descent, hv_Width, hv_Height, hv_RowCenter, hv_ColCenter;
  HTuple  hv_RowPos, hv_ColPos, hv_RowText, hv_ColText;

  //Determine factors for the adaptation of the string extents that might be necessary
  //because of image zooming.
  GetPart(hv_WindowHandle, &hv_Row1Part, &hv_Column1Part, &hv_Row2Part, &hv_Column2Part);
  GetWindowExtents(hv_WindowHandle, &hv_RowWin, &hv_ColumnWin, &hv_WidthWin, &hv_HeightWin);
  hv_FactorRow = (1.*((hv_Row2Part-hv_Row1Part)+1))/hv_HeightWin;
  hv_FactorColumn = (1.*((hv_Column2Part-hv_Column1Part)+1))/hv_WidthWin;
  //
  //Determine the extent of the string and its position.
  GetStringExtents(hv_WindowHandle, hv_Text, &hv_Ascent, &hv_Descent, &hv_Width, 
      &hv_Height);
  hv_Width = hv_Width*hv_FactorColumn;
  hv_Height = hv_Height*hv_FactorRow;
  hv_RowCenter = (hv_RowFirst+hv_RowSecond)/2.0;
  hv_ColCenter = (hv_ColFirst+hv_ColSecond)/2.0;
  if (0 != ((hv_Phi.TupleSin())<0))
  {
    hv_Distance = -hv_Distance;
  }
  hv_RowPos = hv_RowCenter+(hv_Distance*(hv_Phi.TupleCos()));
  hv_ColPos = hv_ColCenter+(hv_Distance*(hv_Phi.TupleSin()));
  hv_RowText = hv_RowPos-(hv_Height/2.0);
  hv_ColText = hv_ColPos;
  //
  //Set the text position and color and display the text.
  SetTposition(hv_WindowHandle, hv_RowText, hv_ColText);
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"black");
  WriteString(hv_WindowHandle, hv_Text);
  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Image1, ho_Image11, ho_Image2, ho_Region;
  HObject  ho_ConnectedRegions, ho_RegionFillUp, ho_SelectedRegions2;
  HObject  ho_SelectedRegions1, ho_RegionClosing, ho_Skeleton;
  HObject  ho_Contours;

  // Local control variables
  HTuple  hv_Width, hv_Height, hv_WindowHandle;
  HTuple  hv_Channels, hv_Grayval, hv_Area, hv_Row, hv_Column;
  HTuple  hv_Number;


  ReadImage(&ho_Image1, //'C:/Users/sunzc/Desktop/羊毛测量/wool/sw0001.jpg'
      "C:/Users/sunzc/Desktop/\321\362\303\253\262\342\301\277/wool/sw0001.jpg");
  //Image Acquisition 01: Do something
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  GetImageSize(ho_Image1, &hv_Width, &hv_Height);
  dev_open_window_fit_image(ho_Image1, 0, 0, -1, -1, &hv_WindowHandle);

  dev_update_off();


  //blob分析挑选出测量区域（形状特征的选择）

  //判断通道数，若为3通道，则对图像灰度化
  CountChannels(ho_Image1, &hv_Channels);
  if (0 != (hv_Channels==3))
  {
    Decompose3(ho_Image1, &ho_Image11, &ho_Image2, &ho_Image1);
  }
  GetGrayval(ho_Image1, 0, 0, &hv_Grayval);

  Threshold(ho_Image1, &ho_Region, 0, hv_Grayval-1);


  Connection(ho_Region, &ho_ConnectedRegions);


  FillUp(ho_ConnectedRegions, &ho_RegionFillUp);

  //形状选择
  SelectShape(ho_RegionFillUp, &ho_SelectedRegions2, "circularity", "and", 0, 0.1676);
  AreaCenter(ho_SelectedRegions2, &hv_Area, &hv_Row, &hv_Column);
  SelectShape(ho_SelectedRegions2, &ho_SelectedRegions1, "area", "and", hv_Area.TupleMax(), 
      9999999);
  ClosingCircle(ho_SelectedRegions1, &ho_RegionClosing, 35);


  Skeleton(ho_RegionClosing, &ho_Skeleton);
  GenContourRegionXld(ho_RegionClosing, &ho_Contours, "border");


  CountObj(ho_SelectedRegions1, &hv_Number);

  if (0 != (hv_Number!=1))
  {
    // stop(...); only in hdevelop
  }








  //显示结果


  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image1, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Skeleton, HDevWindowStack::GetActive());







  // stop(...); only in hdevelop

}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
HTuple      gStartMutex;
H_pthread_t gActionThread;
HBOOL       gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  // Wait until the timer has fired to start processing.
  LockMutex(gStartMutex);
  UnlockMutex(gStartMutex);

  try
  {
    action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
  }

  // Tell the main thread to terminate itself.
  LockMutex(gStartMutex);
  gTerminate = TRUE;
  UnlockMutex(gStartMutex);
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);

  for (;;)
  {
    HBOOL terminate;

    CFRunLoopRun();

    LockMutex(gStartMutex);
    terminate = gTerminate;
    UnlockMutex(gStartMutex);

    if (terminate)
      break;
  }

  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  int ret = 0;

  try
  {
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#elif defined(__linux__) && (defined(__i386__) || defined(__x86_64__))
    XInitThreads();
#endif

    // file was stored with local-8-bit encoding
    //   -> set the interface encoding accordingly
    SetHcppInterfaceStringEncodingIsUtf8(false);

    // Default settings used in HDevelop (can be omitted)
    SetSystem("width", 512);
    SetSystem("height", 512);

#ifndef __APPLE__
    action();
#else
    ret = apple_main(argc,argv);
#endif
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
    ret = 1;
  }
  return ret;
}

#endif


#endif


